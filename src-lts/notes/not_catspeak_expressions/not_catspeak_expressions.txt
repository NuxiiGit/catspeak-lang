An expression is is a term which always produces a value, and may be composed
of many sub-expressions. Most statements you would typically find in GameMaker
Language (GML) appear as expressions in Catspeak. This includes [Break Expressions](#break-expressions), [Return Expressions](#return-expressions), and
[Continue Expressions](#continue-expressions).

For the precedence of many of these expressions, see the [**precedence table**](./lan-lexical-grammar.html#operators) in the [Lexical Grammar](./lan-lexical-grammar.html)
chapter.

# Terminal Expressions

Terminal expressions are either [Identifiers](./lan-lexical-grammar.html#identifiers) or literals (e.g. [Numbers](./lan-lexical-grammar.html#numbers) and [Strings](./lan-lexical-grammar.html#strings)).
These expressions have no further sub-expressions, hence the name.

Examples of terminal expressions:

```meow
"2036-02-03"  -- string literal
#BBE31A       -- colour code
3.1415        -- numeric literal
'K'           -- character literal
0b0011_1110   -- binary literal
true          -- boolean True
undefined
player_name   -- variable identifier
NaN           -- not a number
```

# Grouped Expressions

A grouped expression wraps a single sub-expression between `(` and `)`,
evaluating the sub-expression. This is typically used to make the precedence of
the inner expression clear:

```meow
let a = 1 + 2 * 3    -- a = 7
let b = (1 + 2) * 3  -- b = 9
```

# Array Expressions

Arrays are a sequence of comma-separated sub-expressions wrapped between `[`
and `]`:

```meow
let array = [1, 2, 3]
```

The order of evaluation of sub-expressions `[a, b, c]` is **left-to-right**, i.e.
`a` is evaluated first, then `b`, and finally `c`.

**Whitespace does not matter**, and the elements of an array can be split over
multiple lines if needed (including a trailing comma on the final element if
desired):

```meow
let names = [
  "Jane",
  "June",
  "Jake",
  "Jade",
]
```

For information on how to modify the elements of an array, see the section on
[Accessor Expressions](#accessor-expressions).

# Struct Expressions

Structs are a sequence of comma-separated key-value pairs (`key: value`) wrapped
between `{` and `}`:

```meow
let struct = { x: 1, y: 2 }
```

Just like [Array Expressions](#array-expressions) **whitespace does not matter**,
and the order of evaluation for sub-expressions is **left-to-right**.

Struct keys (seen on the left-hand-side of the `:` symbol) can be any valid
[Terminal Expression](#terminal-expressions):

```meow
let metadata = {
  name   : "Roxy",  -- identifier 'name' used as a key
  "age"  : 21,      -- string "age" used as a key
  0b0110 : 0x42,    -- the binary number '0b0110' used as a key
}
```

Any non-string key will be implicitly converted into a string before being
assigned its value. For example, the identifier `name` becomes `"name"`, and the
binary number `0b0110` becomes `"6"`.

Using an expression for a struct key (so-called _"computed keys"_) is allowed, so
long as the expression is surrounded with `[` and `]`:

```meow
{ ["hello" + "world"]: 123 }
```

If the key and value are both the same identifier `{ x: x, y: y }`, then the
**key can be omitted** in a short-hand initialisation syntax like `{ x, y }`:

```meow
let a = 1
let b = 2
let c = 3

return { a, b, c }  -- this is short for { a: a, b: b, c: c }
```

For information on how to modify the elements of a struct, see the section on
[Accessor Expressions](#accessor-expressions).

# Call Expressions

A call expression is a single sub-expression (the _callee_) followed by a
sequence of comma-separated sub-expressions (the _arguments_) wrapped between
`(` and `)`:

```meow
show_message("hello from Catspeak!")

-- 'show_message' is the callee
-- "hello from Catspeak!" is the argument
```

If the callee is a constructor function from GML, then it can be constructed
by prefixing a call expression with the `new` keyword:

```meow
let v = new Vec2(13, 12)
```

If the constructor does not have any parameters, then the `()` can be omited:

```meow
let player = new Player  -- instead of `new Player()`
```

# Accessor Expressions

An accessor expression will allow you to access or modify the elements of an
array or struct. They consist of a single sub-expression (the array or struct)
followed by a sequence of comma-separated sub-expressions (the indices) wrapped
between `[` and `]`:

```meow
array[0]
struct["y"]
```

If the index is a valid identifier, the `.` symbol can be used for short-hand
member access `vec.x`, which is the same as `vec["x"]`. This is useful
when working with structs:

```meow
let vec = { x: 0, y: 0 }

vec.x = 10
vec.y = vec.x + 12
```

Depending on which side of an [Assignment Expression](#assignment-expressions)
the accessor expression is on, determines whether to read or assign a value.

# Unary Operators

Unary operations are made up of a single sub-expression prefixed by one of
`!`, `~`, `-`, or `+`.

They have the highest [precedence](./lan-lexical-grammar.html#op-unary) of all
operators, even greater than the [Multiplicative Operators](#multiplicative-operators):

```meow
+a - b  -- same as (+a) - b, NOT +(a - b)
-a * d  -- same as (-a) * d, NOT -(a * d)

+-a  -- not valid, unary operators cannot be chained together
     -- parenthesis should be used to resolve ambiguity: +(-a)
```

| Operator | Description |
| -------- | ----------- |
| `!a` | Converts `a` into a Boolean value (True or False), returning `false` if `a` evaluates to True and `true` if `a` evaluates to False. |
| `~a` | Converts `a` into a 32-bit integer, returning a new number whose binary representation flips every 0 to a 1 and every 1 to a 0. e.g. `~0b1010` becomes `0b0101`. |
| `-a` | Converts `a` into a number, returning the number with the opposite sign. If `a` is positive then its negative counterpart is returned, and vice versa. |
| `+a` | Converts `a` into a number, returning that number. |

# Multiplicative Operators

Multiplicative operations are made up of two sub-expressions separated by one of
`*`, `/`, `//`, or `%`.

They have the highest [precedence](./lan-lexical-grammar.html#op-mult) of all
binary operators:

```meow
a + b * c  -- same as a + (b * c), NOT (a + b) * c
a / b - c  -- same as (a * b) - c, NOT a / (b - c)

a * b / c * d  -- same as ((a * b) / c) * d, NOT (a * b) / (c * d)
```

| Operator | Description |
| -------- | ----------- |
| `a * b` | Converts `a` and `b` into numbers, returning the result of multiplying them together. |
| `a / b` | Converts `a` and `b` into numbers, returning the result of dividing `a` by `b`. |
| `a // b` | Converts `a` and `b` into 32-bit integers, returning the quotient after dividing `a` by `b`. |
| `a % b` | Converts `a` and `b` into numbers, returning the remainder after dividing `a` by `b`. <br><br> _The remainder has the **same sign as `a`**; if `a` is positive then the remainder will be positive, and if `a` is negative then the remainder will be negative._ |

# Additive Operators

Additive operations are made up of two sub-expressions separated by one of
`+` or `-`.

They have higher [precedence](./lan-lexical-grammar.html#op-add)
than all other binary operators except the [Multiplicative Operators](#multiplicative-operators):

```meow
a * b + c  -- same as (a * b) + c, NOT a * (b + c)
a - b / c  -- same as a - (b / c), NOT (a - b) / c

a + b - c + d  -- same as ((a + b) - c) + d, NOT (a + b) - (c + d)
```

| Operator | Description |
| -------- | ----------- |
| `a + b` | Converts `a` and `b` into numbers, returning their sum. |
| `a - b` | Converts `a` and `b` into numbers, returning the result of subtracting `b` from `a`. |

# Bitwise Operators

Bitwise operations are made up of two sub-expressions separated by one of
`&`, `|`, `^`, `<<`, or `>>`.

They have a higher [precedence](./lan-lexical-grammar.html#op-bitwise) than
[Relational Operators](#relational-operators), but a lower precedence than
[Additive Operators](#additive-operators).

| Operator | Description |
| -------- | ----------- |
| `a & b` | Converts `a` and `b` to 32-bit integers, returning a new number whose binary representation is the logical **AND** of every bit from `a` and `b`. e.g. `0b1110 & 0b0111` becomes `0b0110`, since: <br><br>1 AND 0 = 0<br>1 AND 1 = 1<br>1 AND 1 = 1<br>0 AND 1 = 0 |
| `a &#124; b` | Converts `a` and `b` to 32-bit integers, returning a new number whose binary representation is the logical **OR** of every bit from `a` and `b`. e.g. `0b1110 &#124; 0b0111` becomes `0b1111`, since: <br><br>1 OR 0 = 1<br>1 OR 1 = 1<br>1 OR 1 = 1<br>0 OR 1 = 1 |
| `a ^ b` | Converts `a` and `b` to 32-bit integers, returning a new number whose binary representation is the logical **XOR** (exclusive **OR**) of every bit from `a` and `b`. e.g. `0b1110 ^ 0b0111` becomes `0b1001`, since: <br><br>1 XOR 0 = 1<br>1 XOR 1 = 0<br>1 XOR 1 = 0<br>0 XOR 1 = 1 |
| `a << b` | Converts `a` and `b` to 32-bit integers, shifting the binary representation of the value `a` to the **left** by `b`-many bits. e.g. `b0110 << 1` becomes `0b1100`. <br><br> _This has the effect of multiplying `a` by 2<sup><code>b</code></sup>._ |
| `a >> b` | Converts `a` and `b` to 32-bit integers, shifting the binary representation of the value `a` to the **right** by `b`-many bits. |


# Relational Operators

Relational operations are made up of two sub-expressions separated by one of
`<`, `<=`, `>`, or `>=`.

They have a higher [precedence](./lan-lexical-grammar.html#op-relation) than
[Equality Operators](#equality-operators), but a lower precedence than
[Bitwise Operators](#bitwise-operators):

```meow
a * b < c   -- same as (a * b) < c, NOT a * (b < c)
a >= b / c  -- same as a >= (b / c), NOT (a >= b) / c

a < b < c  -- same as (a < b) < c, NOT (a < b) and (b < c)
```

| Operator | Description |
| -------- | ----------- |
| `a < b` | Converts `a` and `b` into numbers, returning whether `a` is less than `b`. |
| `a <= b` | Converts `a` and `b` into numbers, returning whether `a` is less than or equal to `b` |
| `a > b` | Converts `a` and `b` into numbers, returning whether `a` is greater than `b`. |
| `a >= b` | Converts `a` and `b` into numbers, returning whether `a` is greater than or equal to `b` |

# Equality Operators

Equality operations are made up of two sub-expressions separated by one of `==`
or `!=`.

They have a higher [precedence](./lan-lexical-grammar.html#op-equal) than
[Bitwise Operators](#bitwise-operators), but a lower precedence than
[Relational Operators](#relational-operators):

```meow
a * b == c  -- same as (a * b) == c, NOT a * (b == c)
a != b < c  -- same as a != (b < c), NOT (a != b) < c

a == b == c  -- same as ((a == b) == c), NOT (a == b) and (b == c)
```

| Operator | Description |
| -------- | ----------- |
| `a == b` | Compares the values of `a` and `b`, returning `true` if they are equal. <br><br> _Equivalence is determined by the behaviour of GML equality._ |
| `a != b` | Compares the values of `a` and `b`, returning `true` if they are not equal. |

# Pipe Operators

Pipe operations are made up of two sub-expressions separated by one of
`<|` or `|>`.

They have a higher [precedence](./lan-lexical-grammar.html#op-pipe) than
[Logical Operators](#logical-operators), but a lower precedence than
[Bitwise Operators](#bitwise-operators).

| Operator | Description |
| -------- | ----------- |
| `a <&#124; b` | Syntactic sugar for a function call `a(b)`. |
| `a &#124;> b` | Syntactic sugar for a function call `b(a)`. |

# Logical Operators

Logical operations are made up of two sub-expressions separated by one of
`and`, `or`, or `xor`.

They have a higher [precedence](./lan-lexical-grammar.html#op-logical) than
[Assignment Expressions](#assignment-expressions), but a lower precedence than
[Pipe Operators](#pipe-operators).

| Operator | Description |
| -------- | ----------- |
| `a and b` | Converts `a` to a Boolean value, returning `b` if `a` evaluates to True. Returns `a` otherwise. <br><br> _Does not evaluate `b` if `a` evaluates to False. This is called [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation)._ |
| `a or b` | Converts `a` to a Boolean value, returning `b` if `a` evaluates to False. Returns `a` otherwise. <br><br> _Just like the `and` operator, `b` is not evaluated if `a` evaluates to True._ |
| `a xor b` | Converts `a` and `b` to a Boolean values, returning `true` if the values of `a` and `b` are different. Returns `false` otherwise. <br><br> _Unlike `and` and `or`, the `xor` operator is **not short-circuiting**._ |

# Assignment Expressions

Assignment expressions are made up of two sub-expressions separated by one of
`=`, `*=`, `/=`, `-=`, or `+=`.

They have the lowest [precedence](./lan-lexical-grammar.html#op-assign) of all
binary operators:

```meow
a = b = c  -- same as a = (b = c), NOT a = c; b = c

-- the result of an assignment expression is always 'undefined'
let a
let b = (a = 2)  -- a is 2, b is undefined
```

The value of the right-hand-side expression will be written to the left-hand-side
assignment target expression.

| Operator | Description |
| -------- | ----------- |
| `a = b` | Writes the value of `b` to `a` |
| `a *= b` | Writes the value of `a * b` to `a` |
| `a /= b` | Writes the value of `a / b` to `a` |
| `a -= b` | Writes the value of `a - b` to `a` |
| `a += b` | Writes the value of `a + b` to `a` |

Valid assignment targets for the expression `a` include [Identifiers](./lan-lexical-grammar.html#identifiers)
(if they refer to a writable variable), and [Accessor Expressions](#accessor-expression).